# 2주차 - 시간복잡도 ~ 힙

## 시간 복잡도

- 시간 복잡도는 알고리즘의 실행 시간이 입력의 크기에 따라 어떻게 변하는지를 나타내는 척도입니다.
- 시간 복잡도는 주로 빅-오 표기법을 사용하여 나타냅니다.

### 빅오 표기법

- 빅오 표기법은 알고리즘의 시간 복잡도를 나타내는 표기법입니다.
- 빅오 표기법은 알고리즘의 실행 시간이 입력 크기에 따라 어떻게 변하는지를 함수로 나타냅니다.
- 함수의 최고차항만을 나타내기 때문에, 계수와 낮은 차수의 항을 제외시킬 수 있습니다.

<aside>
💡 예를 들어, 입력 크기가 n인 배열을 정렬하는 알고리즘이 있다고 가정해 보겠습니다. 
이 알고리즘이 각 요소를 비교하는 연산을 수행한다고 하면, 시간 복잡도는 O(n^2)입니다. 이는 알고리즘의 실행 시간이 입력 크기의 제곱에 비례한다는 것을 의미합니다.

</aside>

- 빅오 표기법의 특징
    - 상수항을 무시합니다.
    - 계수를 무시합니다.
    - 최고차항만 나타냅니다.
- 빅오 표기법은 알고리즘의 효율성을 평가하는 데 사용됩니다.
- 시간 복잡도가 낮은 알고리즘은 입력 크기가 커질수록 실행 시간이 상대적으로 느리게 증가하기 때문에 효율적입니다.

![Untitled](https://github.com/Hju95/github_images/assets/59231743/5644f5bd-e067-4963-b2f3-295128cb052d)

- 빅오 표기법의 종류
    - **상수 시간 (O(1)):** 입력 크기에 관계없이 항상 같은 시간에 실행되는 알고리즘
    - **선형 시간 (O(n)):** 입력 크기가 n배 증가하면 실행 시간이 n배 증가하는 알고리즘
    - **이차 시간 (O(n^2)):** 입력 크기가 n배 증가하면 실행 시간이 n^2배 증가하는 알고리즘
    - **로그 시간 (O(log n)):** 입력 크기가 n배 증가하면 실행 시간이 log n배 증가하는 알고리즘
    - **지수 시간 (O(2^n)):** 입력 크기가 n배 증가하면 실행 시간이 2^n배 증가하는 알고리즘
- 일반적으로 시간 복잡도가 낮은 알고리즘이 더 효율적입니다. 하지만, 알고리즘의 시간 복잡도만으로 알고리즘의 효율성을 완전히 평가할 수는 없습니다. 알고리즘의 복잡성, 메모리 사용량, 정확도 등의 요소도 고려해야 합니다.

### 그 외 비교

| 표기법 | 의미 |
| --- | --- |
| 빅오 (O) | 최악의 경우 시간 복잡도 |
| 빅세타 (Θ) | 평균의 경우 시간 복잡도 |
| 빅오메가 (Ω) | 최선의 경우 시간 복잡도 |

| 자료구조 | 삽입 | 삭제 | 검색 |
| --- | --- | --- | --- |
| 배열 | O(n) | O(n) | O(1) |
| 링크드 리스트 | O(1) | O(n) | O(n) |
| 힙 | O(log n) | O(log n) | O(log n) |
| 트리 | O(log n) | O(log n) | O(n) |
| 해시 테이블 | O(1) | O(1) | O(1) |

---

## 해시 테이블

- 해시 테이블은 키와 값의 쌍을 저장하는 자료구조입니다.
- 키는 중복되지 않는 값이고, 값은 어떤 값이든 될 수 있습니다.
- 해시 테이블은 키로 값을 빠르게 찾을 수 있다는 장점이 있습니다.

![Untitled](https://github.com/Hju95/github_images/assets/59231743/0f1f265b-5b96-41b7-a127-7f391c253b06)

- 해시 테이블의 작동 방식
    1. 키를 해시 함수에 입력하여 고유한 해시 값을 생성합니다.
    2. 생성된 해시 값을 사용하여 해시 테이블의 인덱스를 찾습니다.
    3. 인덱스에서 값을 가져옵니다.
- 해시 함수는 키를 고유한 해시 값으로 변환하는 함수입니다.
- 해시 함수는 일반적으로 키의 길이와 해시 테이블의 크기를 고려하여 설계됩니다.
- 해시 테이블의 시간 복잡도는 일반적으로 O(1)입니다. 이는 키로 값을 찾는 데 걸리는 시간이 항상 일정하다는 것을 의미합니다.
- 해시 테이블의 용도
    - 검색: 키로 값을 빠르게 찾는 데 사용됩니다.
    - 캐싱: 자주 사용되는 데이터를 저장하는 데 사용됩니다.
    - 맵: 키와 값의 쌍을 저장하는 데 사용됩니다.

**장점**

- 키로 값을 빠르게 찾을 수 있습니다.
- 메모리를 효율적으로 사용할 수 있습니다.

**단점**

- 해시 충돌이 발생할 수 있습니다.
- 해시 함수의 성능에 따라 성능이 달라질 수 있습니다.

- 해시 충돌
    - 해시 충돌은 두 개 이상의 키가 동일한 해시 값을 갖는 경우를 말합니다.
    - 해시 충돌이 발생하면 해시 테이블은 충돌을 해결하기 위한 방법을 사용합니다.
        
        일반적으로 충돌을 해결하기 위해 체인링크, 오픈 어드레싱, 리스트 테이블 등의 방법을 사용합니다.
        
    - 해시 함수의 성능은 해시 테이블의 성능에 중요한 영향을 미칩니다. 해시 함수가 잘 설계되지 않으면 해시 충돌이 자주 발생하여 성능이 저하될 수 있습니다.

### 해시 테이블과 맵의 비교

| 구분 | 해시 테이블 | 맵 |
| --- | --- | --- |
| 키와 값의 쌍으로 구성 | 해시 테이블은 키와 값의 쌍으로 구성됩니다. | 맵은 키와 값의 쌍으로 구성됩니다. |
| 해시 함수를 사용 | 해시 함수를 사용하여 키를 해시 값으로 변환하고, 이를 인덱스로 사용합니다. | 해시 함수를 사용하지 않고, 키를 직접 인덱스로 사용합니다. |
| 검색 속도가 빠름 | 해시 함수를 사용하여 키를 해시 값으로 변환하고, 이를 인덱스로 사용하기 때문에 검색 속도가 빠릅니다. | 키를 직접 인덱스로 사용하기 때문에 검색 속도가 빠릅니다. |
| 메모리를 효율적으로 사용 | 일정한 크기의 메모리를 할당받아 사용하기 때문에, 필요한 만큼의 메모리만 사용하여 효율적인 공간 사용이 가능합니다. | 메모리를 효율적으로 사용하기 위해 다양한 알고리즘을 사용합니다. |
| 동기화 가능 | 여러 스레드가 동시에 접근할 수 있는 자료구조로, 동기화를 통해 일관성을 유지할 수 있습니다. | 여러 스레드가 동시에 접근할 수 있는 자료구조로, 동기화를 통해 일관성을 유지할 수 있습니다. |
| 해시 충돌 발생 가능 | 해시 충돌 등의 문제가 발생할 수 있으므로, 이를 해결하기 위한 방법이 필요합니다. | 해시 충돌 등의 문제가 발생하지 않습니다. |

---

## 트리

- 트리는 노드와 링크로 구성된 비선형 자료구조입니다.
- 트리의 각 노드는 데이터를 저장하고, 노드 간의 연결은 링크로 이루어집니다.
- 트리의 루트 노드는 트리의 시작 노드이고, 나머지 노드는 루트 노드의 자식 노드입니다.
- 트리의 특징
    - 트리는 계층적인 구조를 가지고 있습니다.
    - 트리의 각 노드는 최대 두 개의 자식 노드를 가질 수 있습니다.
    - 트리의 루트 노드는 다른 노드의 부모 노드가 아닙니다.
- 트리의 용도
    - **데이터 저장:** 트리는 계층적인 구조를 가지고 있기 때문에 데이터를 효율적으로 저장할 수 있습니다.
    - **탐색:** 트리는 루트 노드에서 시작하여 자식 노드를 따라 내려가면서 데이터를 탐색할 수 있습니다.
    - **정렬:** 트리를 사용하여 데이터를 정렬할 수 있습니다.
- 트리의 종류
    - **이진 트리:** 각 노드가 최대 두 개의 자식 노드를 가지는 트리입니다.
    - **이진 탐색 트리:** 각 노드의 데이터가 왼쪽 자식 노드의 데이터보다 크거나 같고, 오른쪽 자식 노드의 데이터보다 작은 트리입니다.
    - **AVL 트리:** 균형이 잘 잡힌 이진 탐색 트리입니다.
    - **레드-블랙 트리:** 균형이 잘 잡힌 이진 탐색 트리입니다.

다음은 이진 트리의 예시입니다.

<aside>
💡         `10
      /   \
     5     15
    / \   / \
   2   7  12  20`

</aside>

<aside>
💡 이 트리의 루트 노드는 10이고, 자식 노드는 5와 15입니다. 5의 자식 노드는 2와 7이고, 15의 자식 노드는 12와 20입니다.

</aside>

![Untitled](https://github.com/Hju95/github_images/assets/59231743/50248342-bf8d-4b05-92b4-4248c5b917d6)

- 트리 관련 용어
    - 루트 노드 : 부모가 없는 최상위 노드
    - 단말 노드 : 자식이 없는 노드
    - 크기 : 트리에 포함된 모든 노드의 개수
    - 깊이 : 루트 노드부터의 거리
    - 높이 : 깊이 중 최댓값
    - 차수 : 각 노드의 (자식 방향) 간선 개수

- 기본적으로 트리의 크기가 N 일 때, 전체 간선의 개수는 N-1 개 입니다.

- 이진 탐색 트리
    - 이진 탐색이 동작할 수 있도록 고안된 효울적인 탐색이 가능한 자료구조의 일종
    - 이진 탐색 트리의 특징 : 왼쪽 자식 노드 < 부모 노드 < 오른쪽 자식 노드
        - 부모 노드보다 왼쪽 자식 노드가 작습니다,
        - 부모 노드보다 오른쪽 자식 노드가 큽니다.

- 트리의 순회
    - 트리 자료구조에 포함된 노드를 특정한 방법으로 한 번씩 방문하는 방법을 의미
        - 트리의 정보를 시각적으로 확인할 수 있습니다.
    - 대표적인 트리 순회 방법은 다음과 같습니다.
        - 전위 순회 : 루트를 먼저 방문합니다
        - 중위 순회 : 왼쪽 자식을 방문한 뒤에 루트를 방문합니다
        - 후위 순회 : 오른쪽 자식을 방문한 뒤에 루트를 방문합니다.

![Untitled](https://github.com/Hju95/github_images/assets/59231743/078c9307-2370-4933-b014-3ccb3c41e3b6)

---

## 힙

- 힙은 최댓값 또는 최솟값을 빠르게 찾아내는 연산을 수행하기 위해 고안된 완전 이진 트리(complete binary tree)를 기본으로 한 자료구조입니다.
- 힙의 특징
    - 힙은 완전 이진 트리 구조를 가지고 있습니다.
    - 힙은 최댓값 또는 최솟값을 찾는 연산을 O(log n)의 시간 복잡도로 수행할 수 있습니다.
    - 힙은 중복된 값을 허용합니다.
- 힙의 용도
    - **우선순위 큐:** 힙은 최댓값 또는 최솟값을 빠르게 찾는 연산을 수행할 수 있기 때문에 우선순위 큐를 구현하는 데 사용됩니다.
    - **정렬:** 힙은 최댓값 또는 최솟값을 빠르게 찾는 연산을 수행할 수 있기 때문에 데이터를 정렬하는 데 사용될 수 있습니다.

힙의 종류

- **최대 힙:** 부모 노드의 값이 자식 노드의 값보다 크거나 같은 완전 이진 트리입니다.
- **최소 힙:** 부모 노드의 값이 자식 노드의 값보다 작거나 같은 완전 이진 트리입니다.

![Untitled](https://github.com/Hju95/github_images/assets/59231743/97c05563-8cf2-486d-bc5a-cc148759ec5f)
