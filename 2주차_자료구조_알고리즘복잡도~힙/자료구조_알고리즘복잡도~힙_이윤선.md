1. 시간복잡도
2. 해시 테이블 (Hash Table)
3. 트리(Tree)
4. 힙(Heep)

---

## 시간복잡도

여행을 간다면 목적지 까지 갈 수 있는 방법은 다양할 것이다. 목적지에 따라서 차, 비행기, 기차 등 어떤 것을 타고갈지, 어떤 길로 가는게 가장 효율적인지에 대한 방법은 여러가지가 있을 것이다.

알고리즘도 마찬가지다. 문제를 푸는데 다양한 알고리즘이 있을 수 있지만 가장 좋은 알고리즘을 측정하고 분석하는게 중요하다. 알고리즘의 성능을 분석하는 개념으로 **시간복잡도**, **공간복잡도**가 있다.

| 요소 | 시간 복잡도 | 공간 복잡도 |
| --- | --- | --- |
| 정의 | 알고리즘의 실행 시간을 측정 | 알고리즘의 메모리 사용량을 측정 |
| 목표 | 알고리즘의 작동 속도 평가 | 메모리 사용량 평가 |
| 표기법 | 주로 빅 오(O) 표기법 사용 (예: O(n), O(log n)) | 주로 공간 복잡도 함수로 표기 (예: S(n)) |
| 의미 | 입력 크기에 대한 알고리즘의 실행 시간의 증가율 | 입력 크기에 대한 알고리즘의 메모리 사용량 증가율 |
| 예시 | - 배열의 합 구하기: O(n) | - 배열의 합 구하기: S(1) (고정 메모리 사용) |
| 예시 | - 이진 검색: O(log n) | - 행렬 곱셈: S(n^2) (행렬 크기에 비례) |
| 최악/평균/최선 경우 분석 | 주로 최악 경우 시나리오를 고려 | 주로 최악 경우 시나리오를 고려 |
| 종속성 | 주로 알고리즘의 효율성과 속도에 관련 | 주로 메모리 사용량과 메모리 관리와 관련 |

알고리즘 시간 복잡도의 주요요소는 반복문이다. 입력의 크기가 커질수록 반복문이 알고리즘 수행 시간을 지배하기 때문이다.

### 알고리즘 성능 표기법

- **빅 오(O) 표기법 : O(N)**
    - 알고리즘의 **최악**의 실행 시간을 나타낸다.
    - 가장 일반적으로 많이 사용되며 알고리즘의 상한을 나타낸다.
        - 상한 : 어떤 입력 크기에 대해 얼마나 나빠질 수 있는지를 설명함.
    - 어떤 입력에 대해서도 알고리즘의 실행 시간이 이 표기법으로 나타낸 것보다 나빠지지 않음을 의미
- **오메가 표기법**
    - 알고리즘의 **최상의 실행 시간**을 나타낸다.
    - 이 표기법은 알고리즘의 하한을 나타내며, 최선의 경우에 실행 시간을 나타낸다.
    - 알고리즘이 항상 최상의 성능을 보장함을 의미함.
- **세타 표기법**
    - 알고리즘의 **평균 실행 시간**을 나타낸다.
    - 알고리즘의 평균 실행 시간을 나타내며, 최악이나 최선의 경우가 아닌 일반적인 경우를 다룬다.
    - 알고리즘이 평균적으로 어떤 성능을 보이는지를 나타낸다.

**빅 오(O) 표기법**

![Untitled](https://github.com/yoonseon12/cs-study/assets/59242594/7baf6ffb-90c3-4483-b76a-9367b5c663d2)


| 표기법 | 설명 |
| --- | --- |
| O(1) | 상수 시간 복잡도. 입력 크기와 무관한 고정 실행 시간. |
| O(log n) | 로그 시간 복잡도. 입력 크기의 로그에 비례하는 실행 시간. |
| O(n) | 선형 시간 복잡도. 입력 크기에 직접 비례하는 실행 시간. |
| O(n log n) | 선형 로그 시간 복잡도. 입력 크기와 로그의 곱에 비례하는 실행 시간. |
| O(n^2) | 이차 시간 복잡도. 입력 크기의 제곱에 비례하는 실행 시간. |
| O(2^n) | 지수 시간 복잡도. 입력 크기에 대해 지수적으로 증가하는 실행 시간. |

---

## **해시 테이블**

**해시 구조**

- **해시 테이블 (Hash Table)**: 데이터를 키(key)와 값(value)의 쌍으로 저장하는 데이터 구조. 데이터를 빠르게 검색할 수 있는 장점을 갖고 있다.
- **빠른 검색**: 키를 통해 데이터를 직접 가져올 수 있어서 검색 속도가 매우 빠르다.
- **배열 사용**: 보통 미리 배열로 Hash Table 사이즈만큼 생성한 후 사용하며, 이로써 공간과 탐색 시간을 교환함.

**참고 용어**

- **해시 (Hash)**: 임의 값을 고정 길이로 변환하는 과정을 의미한다.
- **해시 테이블 (Hash Table)**: 키 값에 의해 직접 데이터에 접근할 수 있는 데이터 구조
- **해싱 함수 (Hashing Function)**: 키에 대해 산술 연산을 사용하여 데이터의 위치를 찾을 수 있는 함수
- **해시 값 또는 해시 주소 (Hash Value or Hash Address)**: 키를 해싱 함수를 사용하여 연산한 값으로, 이를 기반으로 해당 키에 대한 데이터 위치를 일관되게 찾을 수 있음
- **슬롯 (Slot)**: 데이터를 저장할 수 있는 공간
- **키 추출 함수 (Key Extraction Function)**: 데이터에 대한 키를 추출할 수 있는 별도의 함수가 존재할 수 있다.

### **해시 테이블(Hash Table)의 장단점과 주요 용도**

**장점:**

- **빠른 데이터 접근과 검색 속도:** 해시 테이블은 키를 해시 함수를 사용하여 주소로 변환하므로 데이터에 빠르게 접근할 수 있다. 이로 인해 검색 속도가 매우 빠름
- **중복 검사 용이:** 각 키에 대한 해시값은 고유하며, 중복된 키를 쉽게 감지할 수 있다.

**단점:**

- **추가적인 저장 공간 요구:** 일반적으로 해시 테이블은 미리 정의된 크기의 배열로 구현되므로 저장 공간을 미리 할당해야 한다.
- **충돌 처리 필요:** 서로 다른 키가 동일한 해시값을 가질 때 충돌이 발생하며, 이를 처리하기 위한 별도의 자료구조가 필요하다.

**주요 용도:**

- **빠른 검색이 필요한 경우:** 해시 테이블은 빠른 검색 속도를 제공하기 때문에 검색이 많이 필요한 상황에서 유용하다.
- **데이터 저장, 삭제, 읽기가 빈번한 경우:** 데이터의 빈번한 추가, 삭제, 및 조회 작업에 적합하다.
- **캐시 구현:** 캐시 메모리와 같은 용도로 중복 데이터를 효율적으로 관리하기 위해 사용되며 중복 확인이 쉬워 중복 데이터를 방지하는 데 효과적이다.

### 충돌(Collision) 연결 알고리즘

해쉬 테이블의 가장 큰 문제는 충돌의 경우이다. 이 문제를 충돌 또는 해쉬 충돌 이라고 부른다.

- **Chaining 기법 (개방 해싱)**
    - **충돌 해결 방식:** 충돌이 발생하면 해시 테이블의 해당 위치에 데이터를 바로 저장하는 대신, 링크드 리스트(Linked List)와 같은 자료 구조를 활용하여 데이터를 추가로 연결한다.
    - **연결:** 동일한 해시값을 갖는 데이터는 링크드 리스트로 연결되어 저장됩니다. 따라서 한 버킷(해시 테이블의 한 위치)에 여러 데이터가 연쇄적으로 저장된다.
    - **유연한 공간 활용:** Chaining은 추가적인 메모리 공간을 사용하여 충돌 데이터를 저장하므로, 충돌이 적으면 많은 메모리를 사용하지 않습니다.
    - **검색 및 삽입:** 데이터 검색 시, 해당 위치에서 링크드 리스트를 순회하여 원하는 데이터를 찾는다. 데이터 삽입 시, 새로운 데이터를 해당 위치의 링크드 리스트에 추가한다.

- **Linear Probing 기법 (폐쇄 해싱)**
    - **충돌 해결 방식:** 충돌이 발생하면 해당 해시 주소 이후의 주소를 차례로 확인하여 첫 번째로 나오는 빈 공간에 데이터를 저장하는 방식이다.
    - **저장 공간 활용도 향상:** Linear Probing은 저장 공간 내에서 연속적으로 데이터를 저장하므로 저장 공간 활용도를 높일 수 있다.
    - **검색 및 삽입:** 데이터 검색 시, 해당 해시 주소부터 시작하여 빈 공간을 찾아 데이터를 확인한다. 데이터 삽입 시, 해당 해시 주소 이후부터 시작하여 첫 번째 빈 공간에 데이터를 추가한다.

암호화 때 자주 사용했던 SHA(Secure Hash Algorithm) 알고리즘도 해싱 알고리즘임.

해쉬 함수을 재정의 하거나 해쉬 테이블 저장공간을 확대하면 빈번한 충돌을 개선할 수 있음.

---

## 트리(Tree)

**트리(Tree) 구조**

- **트리**: 노드(Node)와 가지(Branch)를 사용하여 사이클을 형성하지 않는 데이터 구조
- 트리 중 이진 트리 (Binary Tree) 형태의 구조로, 탐색(검색) 알고리즘 구현을 위해 많이 사용됨

트리 구조는 데이터의 계층 구조를 표현하고, 효율적인 데이터 검색 및 정렬 알고리즘을 구현하는 데 중요한 역할을하며 이진 트리는 데이터의 효율적인 관리와 검색에 매우 유용한 구조 중 하나이다.

**트리** **알아둘 용어**

- **Node (노드)**: 트리에서 데이터를 저장하는 기본 요소로, 데이터와 다른 연결된 노드에 대한 Branch 정보를 포함한다.
- **Root Node (루트 노드)**: 트리의 맨 위에 위치하는 노드로, 모든 다른 노드는 루트 노드로부터 어떤 경로로든 연결된다.
- **Level (레벨)**: 최상위 노드를 Level 0으로 정의했을 때, 하위 Branch로 연결된 노드의 깊이를 나타낸다. Level 1은 루트 노드의 자식 노드를 나타내며, 이후 Level은 계층적으로 증가함
- **Parent Node (부모 노드)**: 어떤 노드의 바로 상위 레벨에 연결된 노드를 가리킨다.
- **Child Node (자식 노드)**: 어떤 노드의 상위 레벨에 연결된 노드를 가리킨다.
- **Leaf Node (Terminal Node) (말단 노드)**: Child Node가 하나도 없는 노드로, 트리의 끝에 위치한 노드
- **Sibling (Brother Node) (형제 노드)**: 동일한 Parent Node를 가진 노드들을 가리킨다. 즉, 같은 부모를 가진 형제 노드라고 볼 수 있다.
- **Depth (깊이)**: 트리에서 Node가 가질 수 있는 최대 Level을 낸다. Depth는 트리의 최대 레벨을 나타낸다.

**이진 트리와 이진 탐색 트리 (Binary Search Tree, BST)**

- **이진 트리 (Binary Tree)**: 각 노드가 최대 2개의 Branch(자식 노드)를 가지는 트리 구조를 의미한다.
- **이진 탐색 트리 (Binary Search Tree, BST)**: 이진 트리에 다음과 같은 추가적인 조건이 있는 트리임.
    - 왼쪽 노드는 해당 노드보다 작은 값을 가지며, 오른쪽 노드는 해당 노드보다 큰 값을 가진다.

**이진 탐색 트리의 장점과 주요 용도**

- **주요 용도** : 이진 탐색 트리는 주로 데이터 검색(탐색)에 사용된다.
- **장점** : 이진 탐색 트리의 가장 큰 장점은 탐색 속도를 개선할 수 있다는 것으로 데이터를 효율적으로 저장하고 검색하는 데 유용하며, 데이터의 정렬된 순서를 유지할 수 있다.

---

## **힙(Heep)**

- 힙은 데이터에서 최대값과 최소값을 빠르게 찾기 위해 고안된 완전 이진 트리(Complete Binary Tree) 구조이다.
- **완전 이진 트리**: 힙은 완전 이진 트리 구조를 따른다. 이는 노드를 삽입할 때 최하단 왼쪽 노드부터 차례대로 삽입하는 트리 구조를 의미한다.

**힙을 사용하는 이유**

- **데이터 삽입 및 최대/최소 값 검색 시간 단축**: 배열에 데이터를 넣고 최대값 또는 최소값을 찾으려면 모든 요소를 확인해야 하므로 O(n)의 시간이 걸린다. 그러나 힙을 사용하면 데이터를 넣고 최대값 및 최소값을 찾을 때 O(log n)의 시간이 걸림. 이는 데이터 양이 증가할수록 힙이 빠르게 처리할 수 있다는 것을 의미한다.
- **우선순위 큐 및 관련 알고리즘 구현**: 힙은 우선순위 큐와 같이 최대값 또는 최소값을 빠르게 찾아야 하는 다양한 알고리즘에서 사용된다.

**힙 (Heap) 구조**

힙은 최대값을 구하기 위한 구조인 최대 힙(Max Heap)과 최소값을 구하기 위한 구조인 최소 힙(Min Heap)으로 분류할 수 있습니다. 

- **최대 힙 (Max Heap)**의 경우는 ****각 노드의 값은 해당 노드의 자식 노드가 가진 값보다 크거나 같아야 한다. 즉, 최대 힙에서는 루트 노드가 가장 큰 값을 가지며, 각 노드는 자식 노드보다 큰 값을 가져야 함.
- **최소 힙 (Min Heap)**의 경우는 각 노드의 값이 해당 노드의 자식 노드가 가진 값보다 작거나 같아야 함.
- **완전 이진 트리 형태**: 힙은 완전 이진 트리의 형태를 가져야 한다. 완전 이진 트리는 노드를 최하단 왼쪽 노드부터 차례대로 채워가는 트리 구조를 의미한다.

**힙과 이진 탐색 트리의 공통점과 차이점**

- **공통점**: 힙과 이진 탐색 트리는 모두 이진 트리의 형태를 가지고 있다.
- **차이점**:
    - **힙**:
        - 각 노드의 값은 해당 노드의 자식 노드가 가진 값보다 크거나 같아야 한다. (최대 힙의 경우).
        - 최소 힙의 경우, 각 노드의 값은 해당 노드의 자식 노드가 가진 값보다 작거나 같아야 한다.
        - 힙에는 이진 탐색 트리의 조건인 "왼쪽 자식 노드의 값이 가장 작고, 그 다음은 부모 노드, 그 다음은 오른쪽 자식 노드의 값이 가장 크다"는 조건이 없디. 즉, 힙의 왼쪽 및 오른쪽 자식 노드의 값은 오른쪽이 클 수도 있고, 왼쪽이 클 수도 있다.
    - **이진 탐색 트리 (BST)**:
        - 이진 탐색 트리는 각 노드의 왼쪽 자식 노드 값이 현재 노드의 값보다 작고, 오른쪽 자식 노드 값이 현재 노드의 값보다 크다는 조건을 가진다.
        - 이진 탐색 트리는 데이터를 탐색하기 위한 구조로 사용되며, 데이터의 정렬된 순서를 유지.

힙 참고 영상 : https://www.youtube.com/watch?v=AjFlp951nz0
