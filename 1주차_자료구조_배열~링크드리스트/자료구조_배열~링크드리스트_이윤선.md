1. 배열(Array)
2. 큐(Queue)
3. 스택(Stack)
4. 링크드 리스트(LinkedList)
5. 더블 링크드 리스트(Doubly LinkedList)
---
<br>   

### 배열(Array)

- 데이터를 각 인덱스를 통해 할당한 데이터 구조로 같은 종류의 데이터를 효율적으로 관리하기 위해 사용한다.
- 장점 : 빠른 접근이 가능하다.
- 단점 : 배열 크기는 미리 설정해야하고 변경할 수 없다. 추가, 삭제가 쉽지 않다.
<br>


### 큐(Queue)

- 먼저 들어간 자료가 먼저 나오는 구조 FIFO(First In FIrst Out) 구조이다. (ex.에스컬레이터)
- 운영체제에서 멀티 태스킹을 위한 프로세스 스케줄링 방식에 많이 사용된다.
- Queue : 가장 일반적인 큐 자료 구조
- PriorityQueue : 우선순위가 높은순으로 데이터를 출력하는 큐 자료 구조

```java
import java.util.LinkedList; //import
import java.util.Queue; //import
Queue<String> queue_str = new LinkedList<>(); //String형 queue 선언, linkedlist 이용
Queue<Integer> queue = new LinkedList<>(); //int형 queue 선언

queue.offer(1);     // queue에 값 1 추가
queue.offer(2);     // queue에 값 2 추가
queue.poll();       // queue에 첫번째 값을 반환하고 제거 비어있다면 null
queue.remove();     // queue에 첫번째 값 제거
queue.clear();      // queue 초기화
queue.peek();       // queue의 첫번째 값 확인
```

**자바에서는 왜 Queue를 ArrayList가 가인 linkedList로 구현해야할까?**

- ArrayList는 배열 기반의 자료 구조이기 떄문에 빈 공간을 채우기 위해서 데이터의 복사가 발생하므로 매우 비효율적이다. 하지만 LinkedList는 데이터 추가하거나 삭제할 때 요소 간의 링크만 조절하면 되므로 삽입 삭제가 효율적이다. 큐에서는 삽입, 삭제가 빈번하게 일어나기 때문에 대부분 LinkedList로 구현한다.
<br>

## 스택(Stack)

- 가장 나중에 쌓은 데이터를 가장 먼저 빼낼 수 있는 데이터 구조이다.(ex.책을 차곡차곡 쌓아올린 형태)
- 언제나 목록의 끝에서 접근할 수 있기 때문에 접근 방법이 제한적임
- LIFO or FILO
- 스택의 대표적으로 활용 되는곳은 컴퓨터 내부의 프로세스 구조의 함수 동작 방식이 있다.
    - 재귀함수는 스택프레임을 사용하여 호출된 함수의 매개변수, 호출이 끝난 뒤 돌아갈 반환 주소 값, 함수에서 선언된 지역 변수 등이 저장된다.

```java
import java.util.Stack; //import
Stack<String> stack_str = new Stack<>(); //char형 스택 선언
Stack<Integer> stack = new Stack<>(); //int형 스택 선언

stack.push(1);     // stack에 값 1 추가
stack.pop();       // stack에 값 제거
stack.clear();     // stack의 전체 값 제거 (초기화)
stack.peek();     // stack의 가장 상단의 값 출력
```

<br>

## 링크드 리스트(LinkedList)

- 링크드 리스트는 떨어진 곳에 존재하는 데이터를 화살표로 연결해서 관리하는 데이터 구조
- 데이터의 저장단위인 노드와 각 노드에서 다음이나 이전 노드와 연결하는 공간인 포인터로 구성되있다.

**링크드 리스트의 장단점**

- 장점
    - 배열과 다르게 미리 데이터 공간을 할당하지 않아도됨
- 단점
    - 연결을 위한 별도의 데이터 공간이 필요하므로, 저장공간 효율이 높지 않음
    - 연결 정보를 찾는 시간이 필요하므로 접근 속도가 느림
    - 중간 데이터를 삭제할 경우 앞뒤 데이터의 연결을 재 구성 해야하는 작업이 필요함.
    

**그렇다면 링크드 리스트와 배열은 뭐가 다를까?**

1. 메모리 할당 구조
    1. 배열은 순차적으로 연결된 공간에 데이터를 할당한다.
    2. 링크드 리스트는 연결된 노드로 데이터를 할당한다.
2. 크기
    1. 배열은 데이터를 할당할 수 있는 크기가 고정되어 있다.
    2. 링크드 리스트는 동적 크기를 가지며 노드를 추가하거나 제거할 수 있다.
3. 메모리 사용량
    1. 배열은 크기가 고정되어있기 때문에 비교적 메모리 사용량이 적다.
    2. 링크드 리스트는 연결을 위한 별도의 데이터 공간이 필요하므로, 메모리 사용량이 배열보다 높다.
4. 구현 복잡성
    1. 배열은 비교적 간단하다.
    2. 노드를 생성하고 연결해야하기 때문에 복잡하다.
5. 연결 방법
    1. 배열은 인덱스를 사용하여 요소를 연결한다.
    2. 링크드 리스트는 다음 노드에 대한 포인터를 사용한다.

**추가 함수 구현 로직**

- 링크드 리스트 요소를 하기 위해서는 데이터와 데이터사이에 새로운 노드를 추가할 경우 앞 노드를 새로운 노드로 바꿔주고 새로운 노드의 주소를 다음 노드로 바꿔줘야한다.
- 만약 맨 앞의 노드(head)가 없다면 링크드 리스트가 없다고 판단하고 링크드 리스트의 제일 앞에 노드값을 넣는다.
- 만약 맨 앞의 노드(head)가 없지 않다면 노드를 next하여 마지막 노드까지 순회 후 마지막에 노드를 추가함.

**삭제 함수 구현 로직**

1. head 삭제 : 현재 head 노드 바로 다음 노드를 head로 변경하고 삭제한다. 
2. 중간 or 마지막 노드 삭제 : 삭제할 노드 이전 노드 포인터를 삭제할 노드 다음 노드의 포인터를 변경하고 삭제한다. 마지막 노드라면 다음 노드의 포인터가 없기때 문에 이전 노드의 포인터를 null로 변경하고 삭제한다.
<br>

## 더블 링크드 리스트(Doubly LinkedList)

각 노드가 이전 노드와 다음 노드를 가리킬 수 있는 포인터를 포함하고있다. 양방향으로 연결되어 있기 때문에 양 끝에서 찾으려는 노드에 접근할 수 있다.
